---
phase: 05-demo-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - scripts/demo_engine.py
  - src/main.py
autonomous: true

must_haves:
  truths:
    - "Demo engine reads fixture and inserts records into Supabase with controlled timing"
    - "FastAPI endpoints allow start/pause/reset/speed control from the frontend"
    - "Continuous drip pacing feels like natural intelligence flow, not batch waves"
    - "Reset prompts before clearing tables (or provides clear-first option via API)"
  artifacts:
    - path: "scripts/demo_engine.py"
      provides: "Async playback engine with timing control"
      min_lines: 150
    - path: "src/main.py"
      provides: "FastAPI demo control endpoints"
      contains: "/api/demo"
  key_links:
    - from: "scripts/demo_engine.py"
      to: "scripts/demo_fixture.json"
      via: "JSON file read"
      pattern: "demo_fixture\\.json"
    - from: "scripts/demo_engine.py"
      to: "src/database/client.py"
      via: "Supabase inserts"
      pattern: "get_supabase|supabase.*insert|supabase.*upsert"
    - from: "src/main.py"
      to: "scripts/demo_engine.py"
      via: "Import and invoke engine"
      pattern: "demo_engine|DemoEngine"
---

<objective>
Build the demo playback engine that reads the pre-computed fixture and drip-feeds records into Supabase with controlled pacing, plus FastAPI endpoints so the frontend control bar can start/pause/reset/change speed.

Purpose: This is the core orchestrator that makes the demo work. It takes the static fixture data and animates it into the live Supabase database, causing all dashboard panels to update via their existing realtime subscriptions. The engine handles timing, pacing, and state management.

Output: `scripts/demo_engine.py` (engine class) and updated `src/main.py` (API endpoints)
</objective>

<execution_context>
@/Users/gremmy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gremmy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-demo-integration/05-CONTEXT.md
@.planning/phases/05-demo-integration/05-01-SUMMARY.md

# Key source files
@src/database/client.py
@src/main.py
@scripts/demo_fixture.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create async demo playback engine</name>
  <files>scripts/demo_engine.py</files>
  <action>
Create `scripts/demo_engine.py` with a `DemoEngine` class that manages demo playback state and Supabase insertion.

**Class: DemoEngine**

```python
class DemoEngine:
    """Async demo playback engine for Dragon Watch."""

    def __init__(self):
        self.state: Literal["idle", "playing", "paused"] = "idle"
        self.speed: float = 1.0  # 1.0 = Normal (5 min), 2.5 = Fast (2 min), 0.5 = Slow (10 min)
        self.current_index: int = 0  # Current position in fixture records
        self.fixture: dict | None = None
        self.task: asyncio.Task | None = None  # Background playback task
        self.simulated_seconds_elapsed: float = 0.0  # Track scenario time progress
        self.alert_id: str | None = None  # Track inserted alert ID for updates
```

**Methods:**

1. `load_fixture()` -- Load `scripts/demo_fixture.json` into memory on first use. Cache it.

2. `async start(clear_first: bool = True)` -- Start or resume playback.
   - If `clear_first=True` and state is "idle": Clear all 7 tables in Supabase before starting (DELETE all rows from articles, social_posts, vessel_positions, narrative_events, movement_events, alerts, briefs). Order matters: delete alerts and briefs first (they reference events), then events, then raw data.
   - If state is "paused": Resume from `current_index` without clearing.
   - Set state to "playing" and spawn `self.task = asyncio.create_task(self._playback_loop())`.

3. `async pause()` -- Set state to "paused". The playback loop checks state and stops iterating.

4. `async reset()` -- Cancel playback task if running. Set state to "idle", current_index to 0, simulated_seconds_elapsed to 0. Clear all 7 tables.

5. `set_speed(speed: float)` -- Update speed multiplier. Takes effect immediately on next record's delay calculation.

6. `get_status() -> dict` -- Return current state, speed, progress (current_index / total), simulated_time (map elapsed to T+Xh format), records_inserted count.

7. `async _playback_loop()` -- Core loop:
   ```python
   records = self.fixture["records"]
   while self.current_index < len(records) and self.state == "playing":
       record = records[self.current_index]

       # Calculate delay until next record
       if self.current_index > 0:
           prev_offset = records[self.current_index - 1]["_demo_offset_seconds"]
           curr_offset = record["_demo_offset_seconds"]
           delay = (curr_offset - prev_offset) / self.speed

           # Track simulated time
           self.simulated_seconds_elapsed = curr_offset

           # Wait (but check for pause/stop periodically)
           await self._interruptible_sleep(delay)

           if self.state != "playing":
               break

       # Insert record into Supabase
       await self._insert_record(record)
       self.current_index += 1

   if self.current_index >= len(records):
       self.state = "idle"  # Demo complete
   ```

8. `async _interruptible_sleep(seconds: float)` -- Sleep in small increments (0.1s) so pause/reset can interrupt quickly. Break early if state changes.

9. `async _insert_record(record: dict)` -- Insert single record into correct Supabase table:
   - Read `record["_table"]` and `record["_demo_action"]` and `record["data"]`
   - For articles: upsert on "url" conflict (same as load_demo_data.py pattern)
   - For social_posts, vessel_positions, narrative_events, movement_events: plain insert
   - For alerts: If `_demo_action == "insert"`, do insert and store returned `id` in `self.alert_id`. If `_demo_action == "update"`, update existing alert by `self.alert_id`.
   - For briefs: plain insert
   - Convert any datetime strings to ISO format if needed
   - Log each insertion: `logger.info("record_inserted", table=table, index=self.current_index)`

10. `async _clear_tables()` -- Delete all rows from all 7 tables. Use `supabase.table(name).delete().neq("id", 0).execute()` pattern (delete where id != 0 matches all rows). Delete in order: briefs, alerts, movement_events, narrative_events, vessel_positions, social_posts, articles.

**Singleton:** Create a module-level singleton `demo_engine = DemoEngine()` so the FastAPI endpoints and the engine share state.

**Speed presets (document in docstring):**
- Normal: speed=1.0 (~5 minutes)
- Fast: speed=2.5 (~2 minutes)
- Slow: speed=0.5 (~10 minutes)

Use `structlog` for logging (consistent with rest of codebase). Import `get_supabase` from `src.database.client`.
  </action>
  <verify>
Run: `python -c "from scripts.demo_engine import DemoEngine; e = DemoEngine(); e.load_fixture(); print(f'Loaded {len(e.fixture[\"records\"])} records')"` (should load fixture without errors).
  </verify>
  <done>
DemoEngine class loads fixture, has start/pause/reset/speed methods, inserts records with proper timing and table routing, supports interruptible sleep for responsive control.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add FastAPI demo control endpoints</name>
  <files>src/main.py</files>
  <action>
Add demo control API endpoints to the existing FastAPI app in `src/main.py`.

Read `src/main.py` first to understand the existing structure (it has lifespan, app creation, and existing endpoints).

Add the following endpoints using an APIRouter with prefix `/api/demo`:

```python
from fastapi import APIRouter
from scripts.demo_engine import demo_engine

demo_router = APIRouter(prefix="/api/demo", tags=["demo"])

@demo_router.post("/start")
async def demo_start(clear_first: bool = True):
    """Start demo playback. If clear_first=True, clears all tables first."""
    await demo_engine.start(clear_first=clear_first)
    return demo_engine.get_status()

@demo_router.post("/pause")
async def demo_pause():
    """Pause demo playback."""
    await demo_engine.pause()
    return demo_engine.get_status()

@demo_router.post("/reset")
async def demo_reset():
    """Reset demo to beginning and clear all tables."""
    await demo_engine.reset()
    return demo_engine.get_status()

@demo_router.post("/speed")
async def demo_speed(preset: str):
    """Set speed preset: 'normal' (5min), 'fast' (2min), 'slow' (10min)."""
    speed_map = {"normal": 1.0, "fast": 2.5, "slow": 0.5}
    speed = speed_map.get(preset, 1.0)
    demo_engine.set_speed(speed)
    return demo_engine.get_status()

@demo_router.get("/status")
async def demo_status():
    """Get current demo playback status."""
    return demo_engine.get_status()
```

Include the router: `app.include_router(demo_router)` after app creation.

Add CORS middleware to allow frontend (running on different port) to call the API:
```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Hackathon demo - permissive
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

The `get_status()` response shape should be:
```json
{
  "state": "playing",
  "speed": 1.0,
  "speed_label": "normal",
  "progress": 0.45,
  "records_inserted": 112,
  "total_records": 250,
  "simulated_time": "T+32h",
  "simulated_hours": 32.4
}
```

Where `simulated_time` is calculated from `simulated_seconds_elapsed`: map 300 seconds -> 72 hours, so `hours = (simulated_seconds_elapsed / 300) * 72`, formatted as `T+{hours:.0f}h`.

IMPORTANT: Do NOT remove or modify any existing endpoints or lifespan logic in `src/main.py`. Only ADD the new demo router and CORS middleware.
  </action>
  <verify>
Start the server: `cd "/Users/gremmy/02. Projects/dragon-watch" && python -m uvicorn src.main:app --host 0.0.0.0 --port 8000 &`
Then test endpoints:
```
curl http://localhost:8000/api/demo/status
curl -X POST http://localhost:8000/api/demo/start?clear_first=true
curl http://localhost:8000/api/demo/status
curl -X POST http://localhost:8000/api/demo/pause
curl -X POST http://localhost:8000/api/demo/reset
```
All should return JSON with state field. Kill server after testing.
  </verify>
  <done>
FastAPI app serves `/api/demo/start`, `/api/demo/pause`, `/api/demo/reset`, `/api/demo/speed`, `/api/demo/status` endpoints. CORS enabled. Demo engine controls work via HTTP API.
  </done>
</task>

</tasks>

<verification>
1. `scripts/demo_engine.py` exists with DemoEngine class
2. `src/main.py` includes demo router with 5 endpoints
3. CORS middleware enabled for cross-origin frontend access
4. `/api/demo/status` returns valid JSON with state, speed, progress fields
5. `/api/demo/start` triggers record insertion into Supabase
6. `/api/demo/pause` stops playback without losing position
7. `/api/demo/reset` clears tables and resets to beginning
</verification>

<success_criteria>
- DemoEngine loads fixture and manages playback state
- FastAPI endpoints control the engine via HTTP
- Records insert one-by-one with continuous drip pacing
- Speed changes take effect immediately
- Reset clears all 7 Supabase tables
- Existing FastAPI functionality unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/05-demo-integration/05-02-SUMMARY.md`
</output>
