---
phase: 01-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/main.py
autonomous: false

must_haves:
  truths:
    - "FastAPI app starts and serves health check endpoint"
    - "API endpoints trigger each fetcher as background tasks"
    - "Supabase client initializes on startup and closes on shutdown"
    - "Demo data can be loaded via API endpoint"
  artifacts:
    - path: "src/main.py"
      provides: "FastAPI application with all data ingestion endpoints"
      contains: "FastAPI"
      exports: ["app"]
  key_links:
    - from: "src/main.py"
      to: "src/fetchers/gdelt.py"
      via: "import and background task trigger"
      pattern: "fetch_and_store_articles"
    - from: "src/main.py"
      to: "src/fetchers/telegram.py"
      via: "import and background task trigger"
      pattern: "scrape_and_store_channels"
    - from: "src/main.py"
      to: "src/fetchers/ais.py"
      via: "import and background task trigger"
      pattern: "connect_ais_stream"
    - from: "src/main.py"
      to: "src/database/client.py"
      via: "lifespan initialization"
      pattern: "get_supabase|close_supabase"
---

<objective>
Wire all fetchers into a FastAPI application with trigger endpoints, lifespan management for the Supabase client, and a health check. Then verify the complete Phase 1 system works end-to-end.

Purpose: The FastAPI app is the operational entry point for all data ingestion. Without it, fetchers are isolated modules. This plan connects everything and provides the API surface that will be used for manual triggering, scheduled execution, and Phase 5 demo playback.
Output: Working FastAPI app with endpoints for all data sources, verified with running server.
</objective>

<execution_context>
@/Users/gremmy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gremmy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: FastAPI application with fetcher endpoints and lifespan</name>
  <files>src/main.py</files>
  <action>
    Create the FastAPI application that ties together all data ingestion modules.

    Create `src/main.py` with:

    1. **Lifespan context manager:**
       ```python
       from contextlib import asynccontextmanager

       @asynccontextmanager
       async def lifespan(app: FastAPI):
           # Startup: initialize Supabase client
           supabase = await get_supabase()
           print(f"Supabase client initialized: {supabase is not None}")
           yield
           # Shutdown: close connections
           await close_supabase()
           await close_telegram()  # from telegram fetcher
       ```

    2. **App initialization:**
       - `app = FastAPI(title="Dragon Watch", description="Pre-conflict early warning system", lifespan=lifespan)`

    3. **Health check endpoint:**
       - GET /health -> returns {"status": "ok", "service": "dragon-watch"}
       - Also verifies Supabase connection by calling get_supabase()

    4. **GDELT trigger endpoint:**
       - POST /fetch/gdelt with optional query param `lookback_hours` (default 24)
       - Adds fetch_and_store_articles as background task
       - Returns {"status": "started", "source": "gdelt", "lookback_hours": N}

    5. **Telegram trigger endpoint:**
       - POST /fetch/telegram with optional query param `limit_per_channel` (default 100)
       - Adds scrape_and_store_channels as background task
       - Returns {"status": "started", "source": "telegram", "limit_per_channel": N}

    6. **AIS stream endpoint:**
       - POST /fetch/ais/start -- starts AIS WebSocket stream as asyncio.create_task (NOT BackgroundTasks -- it's a long-running stream)
       - Store the task reference on app.state for later cancellation
       - POST /fetch/ais/stop -- cancels the AIS stream task
       - Returns {"status": "started|stopped", "source": "ais"}

    7. **Demo data endpoint:**
       - POST /demo/load -- runs the demo data loader
       - Import load function from scripts/load_demo_data
       - Returns {"status": "loaded", "articles": N, "posts": N, "positions": N}

    8. **Fetch all endpoint:**
       - POST /fetch/all -- triggers GDELT + Telegram as background tasks (not AIS -- that's a persistent stream)
       - Returns {"status": "started", "sources": ["gdelt", "telegram"]}

    Run with: `uvicorn src.main:app --reload --host 0.0.0.0 --port 8000`

    IMPORTANT: AIS stream is long-running (WebSocket), so use asyncio.create_task() not BackgroundTasks. BackgroundTasks are for one-shot operations. The AIS stream needs explicit start/stop control.
  </action>
  <verify>
    - Start server: `cd "/Users/gremmy/02. Projects/dragon-watch" && timeout 10 uvicorn src.main:app --host 0.0.0.0 --port 8000 &` then:
    - `curl http://localhost:8000/health` returns 200 with status "ok"
    - `curl http://localhost:8000/docs` returns Swagger UI (confirms all endpoints registered)
    - Check all endpoints registered: `grep -c "@app\." src/main.py` should be 6+ (health + 5 trigger endpoints)
    - Kill server after test
  </verify>
  <done>
    FastAPI app starts with Supabase lifespan, serves health check, exposes trigger endpoints for GDELT, Telegram, AIS (start/stop), demo data load, and fetch-all. All fetcher modules wired in. Swagger docs accessible at /docs.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify Phase 1 foundation is complete</name>
  <what-built>
    Complete Phase 1 data ingestion foundation:
    - Supabase schema (7 tables with realtime)
    - GDELT Chinese state media fetcher
    - Telegram OSINT channel scraper
    - AIS WebSocket vessel tracker
    - Simulated 72-hour Taiwan Strait demo dataset
    - FastAPI app wiring everything together
  </what-built>
  <how-to-verify>
    1. Start the server: `uvicorn src.main:app --reload --port 8000`
    2. Open http://localhost:8000/docs to see all endpoints
    3. Hit GET /health -- should return {"status": "ok"}
    4. (If Supabase configured) Hit POST /demo/load to load demo data, verify response shows 50+ articles, 100+ posts, 200+ positions
    5. (If Supabase configured) Check Supabase Dashboard -> Table Editor to see loaded data in articles, social_posts, vessel_positions tables
    6. (If GDELT accessible) Hit POST /fetch/gdelt -- should return started status
    7. Verify all source files exist:
       - src/main.py
       - src/fetchers/gdelt.py
       - src/fetchers/telegram.py
       - src/fetchers/ais.py
       - src/models/schemas.py
       - src/database/client.py
       - supabase/migrations/00001_create_foundation_tables.sql
       - scripts/load_demo_data.py
       - supabase/seed.sql
  </how-to-verify>
  <resume-signal>Type "approved" to complete Phase 1, or describe any issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. FastAPI app starts without import errors
2. All 6+ endpoints registered and visible in Swagger docs at /docs
3. Health check returns 200
4. Each fetcher is importable and callable from main.py
5. Lifespan initializes Supabase client on startup and closes on shutdown
6. All 9 source files from Phase 1 exist and are non-empty
</verification>

<success_criteria>
- `uvicorn src.main:app --port 8000` starts without errors
- GET /health returns 200 with {"status": "ok"}
- POST /fetch/gdelt, /fetch/telegram, /fetch/ais/start, /demo/load all return started/loaded status
- Swagger docs at /docs show complete API surface
- Human verifies the system works end-to-end with demo data (if Supabase configured)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
