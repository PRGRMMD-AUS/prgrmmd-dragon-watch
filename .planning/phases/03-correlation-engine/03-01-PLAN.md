---
phase: 03-correlation-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models/threat_levels.py
  - src/models/correlation.py
  - src/utils/__init__.py
  - src/utils/geo_utils.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "ThreatLevel enum enforces monotonic escalation (GREEN -> AMBER -> RED, never backwards)"
    - "Geographic proximity check correctly identifies points within Taiwan Strait bounding box"
    - "Correlation Pydantic models validate composite scores, sub-scores, and evidence references"
  artifacts:
    - path: "src/models/threat_levels.py"
      provides: "ThreatLevel enum with can_transition_to() and determine_threat_level()"
      exports: ["ThreatLevel", "determine_threat_level"]
    - path: "src/models/correlation.py"
      provides: "Pydantic models for correlation results and alert data"
      exports: ["CorrelationResult", "AlertCreate", "SubScores"]
    - path: "src/utils/geo_utils.py"
      provides: "Geographic matching utilities for Taiwan Strait region"
      exports: ["is_in_taiwan_strait", "TAIWAN_STRAIT_BBOX"]
    - path: "requirements.txt"
      provides: "GeoPandas and Shapely dependencies"
      contains: "geopandas"
  key_links:
    - from: "src/models/threat_levels.py"
      to: "src/llm/config.py"
      via: "threshold constants alignment"
      pattern: "THREAT_LEVELS|GREEN|AMBER|RED"
    - from: "src/utils/geo_utils.py"
      to: "scripts/load_demo_data.py"
      via: "Taiwan Strait bounding box coordinates must match"
      pattern: "118.*23.*122.*26"
---

<objective>
Create the foundation types, Pydantic models, and geospatial utilities needed by the correlation engine.

Purpose: The correlation engine needs type-safe threat levels with monotonic escalation enforcement, structured models for correlation results (composite scores, sub-scores, evidence chains, confidence), and geographic proximity utilities. These must exist before the core correlation logic can be built.

Output: ThreatLevel enum, correlation Pydantic models, geo utilities, updated requirements.txt with GeoPandas/Shapely.
</objective>

<execution_context>
@/Users/gremmy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/gremmy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-correlation-engine/03-CONTEXT.md
@.planning/phases/03-correlation-engine/03-RESEARCH.md

@src/models/schemas.py
@src/llm/schemas.py
@src/llm/config.py
@scripts/load_demo_data.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ThreatLevel enum and correlation Pydantic models</name>
  <files>
    src/models/threat_levels.py
    src/models/correlation.py
  </files>
  <action>
Create `src/models/threat_levels.py`:

1. Define `ThreatLevel` enum (GREEN=1, AMBER=2, RED=3) with:
   - `can_transition_to(new_level)` method that returns True only if new_level.value >= self.value (monotonic escalation enforcement)
   - Keep it as a plain Enum (NOT str, Enum) since `src/llm/schemas.py` already has a `ThreatLevel(str, Enum)` for LLM output. This one is for the correlation engine's state machine. Name it `ThreatLevel` -- the LLM one is in a different module scope and used only for brief generation.

2. Define `determine_threat_level(composite_score: float) -> ThreatLevel` function:
   - GREEN: score < 30
   - AMBER: 30 <= score < 70
   - RED: score >= 70
   - These thresholds should be module-level constants (GREEN_THRESHOLD=30, RED_THRESHOLD=70) so they're tunable, NOT scattered magic numbers.

3. Define `calculate_confidence(narrative_count: int, movement_count: int, geo_match: bool) -> int` function:
   - Base confidence from event counts: min(narrative_count * 15, 40) + min(movement_count * 5, 30)
   - Geographic match bonus: +20 if geo_match else +0
   - Time density bonus: +10 (always, since we're within 72h window)
   - Cap at 95 (never 100% confidence)
   - Return int 0-95

Create `src/models/correlation.py`:

1. `SubScores(BaseModel)`:
   - outlet_score: float (0-100)
   - phrase_score: float (0-100)
   - volume_score: float (0-100)
   - geo_score: float (0-100)

2. `CorrelationResult(BaseModel)`:
   - narrative_event_ids: list[int]
   - movement_event_ids: list[int]
   - composite_score: float (0-100, Field(ge=0, le=100))
   - sub_scores: SubScores
   - threat_level: str (GREEN/AMBER/RED)
   - confidence: int (0-100)
   - geo_match: bool
   - region: str (default "Taiwan Strait")
   - evidence_summary: str (plain-English one-liner describing what triggered the correlation)
   - detected_at: datetime

3. `AlertUpsertData(BaseModel)`:
   - region: str
   - threat_level: str
   - threat_score: float
   - confidence: int
   - sub_scores: dict
   - correlation_metadata: dict (JSONB-ready: narrative_event_ids, movement_event_ids, evidence_summary, detection_history list)
   - updated_at: str (ISO format)

Use Pydantic v2 patterns consistent with existing `src/models/schemas.py` (BaseModel, Field, ConfigDict).
  </action>
  <verify>
Run: `python -c "from src.models.threat_levels import ThreatLevel, determine_threat_level, calculate_confidence; print(ThreatLevel.GREEN.can_transition_to(ThreatLevel.AMBER)); print(not ThreatLevel.RED.can_transition_to(ThreatLevel.GREEN)); print(determine_threat_level(25).name); print(determine_threat_level(50).name); print(determine_threat_level(85).name)"`
Expected output: True, True, GREEN, AMBER, RED

Run: `python -c "from src.models.correlation import CorrelationResult, SubScores, AlertUpsertData; print('Models import OK')"`
  </verify>
  <done>
ThreatLevel enum exists with monotonic escalation enforcement (can_transition_to returns False for de-escalation). determine_threat_level maps scores to GREEN/AMBER/RED correctly. CorrelationResult and AlertUpsertData models validate and serialize. Confidence calculation returns 0-95 based on event counts and geo match.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create geographic utilities and update dependencies</name>
  <files>
    src/utils/__init__.py
    src/utils/geo_utils.py
    requirements.txt
  </files>
  <action>
Create `src/utils/__init__.py` (empty file, makes utils a package).

Create `src/utils/geo_utils.py`:

1. Define Taiwan Strait bounding box constant matching demo data (from load_demo_data.py: 23-26N, 118-122E):
   ```python
   TAIWAN_STRAIT_BBOX = {
       "name": "Taiwan Strait",
       "lon_min": 118.0,
       "lat_min": 23.0,
       "lon_max": 122.0,
       "lat_max": 26.0
   }
   ```

2. `is_in_taiwan_strait(lat: float, lon: float) -> bool`:
   - Uses Shapely `box()` and `Point()` for geometric containment check
   - `from shapely.geometry import Point, box`
   - Create box from TAIWAN_STRAIT_BBOX coords: `box(lon_min, lat_min, lon_max, lat_max)`
   - Return `region_box.contains(Point(lon, lat))`
   - Always use lon, lat order for Shapely (x, y = lon, lat)

3. `check_narrative_geo_match(geographic_focus: str | None) -> bool`:
   - Returns True if geographic_focus contains any of: "Taiwan", "Strait", "Fujian", "strait"
   - Case-insensitive check
   - Returns False if geographic_focus is None or empty
   - This handles matching narrative events' geographic_focus field against the Taiwan Strait region

4. `normalize_min_max(value: float, min_val: float, max_val: float) -> float`:
   - Standard min-max normalization to 0-100 scale
   - If max_val == min_val, return 50.0 (neutral)
   - Clamp result to 0-100 range

Do NOT import GeoPandas here -- Shapely alone is sufficient for single-region containment checks. GeoPandas would be overkill for a single bounding box with <200 points. Use Shapely directly. This avoids the heavyweight GeoPandas dependency for the demo.

Update `requirements.txt`: Add `shapely>=2.0,<3.0` to the Phase 3 section. Do NOT add geopandas -- Shapely alone is sufficient for this phase (single region, simple containment). This saves install time and avoids GDAL/GEOS dependency issues.
  </action>
  <verify>
Run: `pip install shapely>=2.0 && python -c "from src.utils.geo_utils import is_in_taiwan_strait, check_narrative_geo_match, normalize_min_max, TAIWAN_STRAIT_BBOX; print(is_in_taiwan_strait(24.5, 120.0)); print(is_in_taiwan_strait(10.0, 100.0)); print(check_narrative_geo_match('Taiwan Strait')); print(check_narrative_geo_match(None)); print(normalize_min_max(5, 0, 10))"`
Expected: True, False, True, False, 50.0
  </verify>
  <done>
Shapely installed and importable. is_in_taiwan_strait correctly identifies points inside/outside the bounding box. check_narrative_geo_match handles string matching for narrative geographic focus. normalize_min_max produces 0-100 scaled values. requirements.txt updated with shapely dependency.
  </done>
</task>

</tasks>

<verification>
1. All new modules import without errors: `python -c "from src.models.threat_levels import *; from src.models.correlation import *; from src.utils.geo_utils import *; print('All Phase 3 foundation imports OK')"`
2. ThreatLevel monotonic enforcement works: GREEN->AMBER=True, RED->GREEN=False
3. Geographic containment matches demo data coordinates (24.5, 120.0 is in strait; 10.0, 100.0 is not)
4. Pydantic models serialize to JSON (needed for Supabase JSONB columns)
5. No import conflicts with existing src/llm/schemas.py ThreatLevel
</verification>

<success_criteria>
- ThreatLevel enum with monotonic escalation is importable and correct
- Correlation Pydantic models validate composite scores, sub-scores, evidence references
- Geographic utilities correctly identify Taiwan Strait containment
- Shapely installed, no GeoPandas needed
- All imports clean, no circular dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-correlation-engine/03-01-SUMMARY.md`
</output>
